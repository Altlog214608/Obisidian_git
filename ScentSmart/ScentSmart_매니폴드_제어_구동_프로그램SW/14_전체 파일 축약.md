
# FrSmart ScentSmart 펌웨어 C/C++ 소스 통합 정리

## 1. 주요 파일 및 역할 분류

|파일명|역할 및 설명|
|---|---|
|**HostRun.cpp / HostRun.h**|시리얼 통신 인터럽트 핸들링, 명령 패킷 수신, 명령 파싱, 명령별 호출 및 응답 송신 처리 메인 모듈|
|**IOControl.cpp / IOControl.h**|MCU 하드웨어 GPIO 초기화 및 제어 (솔레노이드 밸브, LED, RS485 통신 방향 제어 등)|
|**ScentControl.cpp / ScentControl.h**|향 분사 및 세정 제어 로직 (발향·세정 루프 상태 머신, 타이밍 및 솔레노이드 제어, 상태 관리)|
|**NFSerial.cpp / NFSerial.h**|MCU 하드웨어 UART 직접 제어 라이브러리 (버퍼링, 인터럽트 기반 송수신 처리, 레지스터 제어)|
|**FunctionSerial.c / .h**|통신 프로토콜 관련 유틸 함수 (SLIP 인코딩/디코딩, CRC16 체크섬 계산 및 부착 함수)|
|**MODBUS.c / MODBUS.h**|Modbus 프로토콜 명령 생성 함수 (레지스터 읽기/쓰기 명령 구성)|
|**프로그램 소스 (LabWindows/CVI 코드들)**|PC 측 시리얼 통신 초기화, 송수신 함수, UI 콜백, Modbus 명령 처리, 에러 관리 및 상태 표시|
|**TimerOne.cpp / TimerOne.h**|16bit 타이머 제어를 위한 라이브러리 (PWM 발생, 주기 설정, 인터럽트 처리)|
|**IODefine.h**|MCU 핀 번호 및 입출력 논리 레벨 정의 (MCU 하드웨어 핀과 코드 추상화를 위한 매크로)|
|**known_16bit_timers.h**|다양한 MCU별 16bit 타이머 관련 핀 맵핑 정의 (AVR, Teensy, Arduino 등 지원용)|

## 2. 통신 처리 흐름 — HostRun.cpp 중심

- **시리얼 데이터 수신 과정:**
    
    - UART 인터럽트로 한 바이트씩 수신 (`ISR(USART0_RX_vect)` 호출)
        
    - `SerialHostEvent()` 호출, 수신 시작(STX)부터 끝(ETX)까지 버퍼에 저장
        
    - 플래그 세팅 후 `RunSerialHostDataCheck()`가 명령 해석 실행
        
- **명령 파싱 및 처리:**
    
    - 수신된 패킷 내 명령 코드(`R`, `L`, `S`, `G`, `V` 등) 확인
        
    - 각 명령에 맞는 처리 함수 호출(`RunSerialHostCommandRunScent()`, `RunSerialHostCommandRunClear()` 등)
        
- **명령별 동작:**
    
    - 데이터를 ASCII 문자열로 숫자 변환해서 `RunDelayTime`, `RunScentNo`, `RunPieriod` 설정
        
    - 각 명령 함수에서 향-세정 루프 함수(`DoScentBackLoop()`, `DoClearBackLoop()`) 호출로 실행 시작
        
- **응답 송신:**
    
    - 상태 요청 시 패킷 작성 후 `SerialHostSendData()`로 송신
        
    - 체크섬 계산 및 RS485 송수신 방향 제어 포함
        

## 3. 하드웨어 제어 — IOControl.cpp

- **입출력 핀 초기화 (`InitIO`):**
    
    - 주소 핀, 솔레노이드 출력핀, 상태 LED, RS485 송수신 제어 핀 등 설정
        
- **솔레노이드 밸브 ON/OFF 제어 함수:**
    
    - `SolOn(pin)`, `SolOff(pin)`에서 핀에 신호 쓰고 상태 배열 `SolControlStatus[]` 갱신
        
- **향 및 세정 준비 솔레노이드 설정:**
    
    - `ReadyScentSol(int port)` → 향 분사용 솔레노이드 밸브 조합 ON/OFF
        
    - `ReadyClearSol(int port)` → 세정용 솔레노이드 밸브 조합 제어
        
- **RS485 통신 방향 제어:**
    
    - `RS485_Tx_Enable()`, `RS485_Rx_Enable()`로 모드 전환
        
- **WatchDog 신호용 `LiveSignal()` 포함**
    

## 4. 향 동작 루프 — ScentControl.cpp

- **상태 머신으로 향 분사 및 세정 동작 제어:**
    
    - `RunScentLoop()` 와 `RunClearLoop()` 각각 타이밍과 상태 체크로 단계별 진행
        
- **명령별 실행 함수:**
    
    - `DoScentBackLoop()` → 향 분사 명령 수신 후 내부 변수 설정 및 루프 시작
        
    - `DoClearBackLoop()` → 세정 명령 초기화 및 루프 실행
        
    - `DoStopBackLoop()` → 진행 중인 발향 및 세정 정지 처리
        
    - `DoSetSolZeroValveBroadcastBackLoop()`, `DoSetSolZeroValveBackLoop()` → 밸브 제로 위치 조정 및 상태 세팅
        
- **상태 저장 및 호출 구조:**
    
    - 향 번호별 상태 문자 저장(`RunScentStatus[]`)
        
    - 하드웨어 제어 함수(IOControl의 `ResetSol()`, `ReadyScentSol()`) 연동
        

## 5. 저수준 시리얼 처리 — NFSerial.cpp/h

- **UART 하드웨어 레지스터 직접 제어 및 버퍼링:**
    
    - 송수신 버퍼(64byte 크기), 포인터 이동 방식 원형 버퍼 구현
        
- **인터럽트 기반 수신 처리 (`_rx_complete_irq`), 송신 버퍼 비었을 때 보내기(`_tx_udr_empty_irq`)**
    
- **전송 속도(baud) 설정, 데이터 프레임 구성, 송수신 인터럽트 활성화 및 비활성화 지원**
    
- **API 함수: `begin()`, `end()`, `write()`, `read()`, `available()`, `flush()` 등 구현**
    
- **임베디드 MCU 환경(AVR, Teensy 등) 맞춤 레지스터 제어**
    

## 6. 통신 프로토콜 유틸 — FunctionSerial.c/h

- **SLIP 프로토콜 인코딩/디코딩:**
    
    - 데이터 내 제어문자 인코딩(`EncodeSLIP`) 및 복원(`DecodeSLIP`)
        
- **CRC16 체크섬 계산/검증 함수:**
    
    - 표준 CRC16과 Modbus CRC16 지원
        
    - 송수신 시 무결성 확인 및 패킷 뒤에 CRC 추가(`AttachCRC16`, `AttachModbusCRC`)
        

## 7. Modbus 명령 생성 — MODBUS.c/h

- **주요 Modbus Function Code 정의:**
    
    - 읽기 함수(`MBC_RHR` 등), 쓰기 함수(`MBC_WSR` 등)
        
- **명령 패킷 생성:**
    
    - 단일 레지스터 읽기/쓰기 명령 생성 함수(`ReadRegisters_MODBUS`, `WriteSingeRes_MODBUS`)
        
- **송신 버퍼에 명령 프레임 부분 데이터 세팅 후, 송신함수 호출**
    

## 8. Timer 및 PWM 제어 — TimerOne.cpp/h

- **16비트 타이머1 제어**:
    
    - 주기 설정, 시작/정지, PWM 출력 설정
        
    - MCU별 타이머 해상도 및 클럭 설정 맞춤
        
- **ISR(인터럽트 서비스 루틴) 제공 및 사용자 콜백 연결 지원**
    
- **PWM 듀티 비율 설정 및 핀별 제어 구현**
    
- **특정 MCU(AVR, Teensy, ARM 등) 지원 조건부 컴파일**
    

## 9. 편리한 MCU 핀 정의 및 타이머 핀 — IODefine.h, known_16bit_timers.h

- MCU 핀매핑 별 명확한 매크로 정의(입력 주소핀, 솔레노이드 출력핀, LED, RS485 신호 등)
    
- MCU별 16bit 타이머용 핀 정의로 다양한 보드 호환성 지원
    

# 10. 전체 시스템 동작 개요

|단계|동작 및 역할|
|---|---|
|PC SW가 Modbus 또는 자체 프로토콜 명령 생성|`s_serial` 버퍼에 데이터 작성, CRC·SLIP 적용 후 시리얼 송신|
|MCU UART 인터럽트 수신|`NFSerial` ISR 처리로 바이트 저장, 완성 패킷 전까지 버퍼링|
|HostRun에서 패킷 완성 확인 및 명령 파싱|명령 종류에 따른 분기, 타이밍 및 상태 변수 설정|
|향 분사 및 세정 Loop 제어|`ScentControl`의 상태 머신으로 솔레노이드 제어 및 타이밍 진행|
|IOControl로 하드웨어 GPIO 제어|실제 펌프, 밸브, LED 등 GPIO 출력 조작하여 물리적 동작 발생|
|상태 및 결과 응답 송신|상태 정보를 다시 PC에 Modbus 또는 프로토콜 형태로 송신|

# 11. 요약 및 팁

- **각 파일은 역할이 명확하게 분리되어 있어 유지보수와 확장이 용이함**
    
- **시리얼 프로토콜과 버퍼, 인터럽트 처리에 익숙해지는 것이 핵심임**
    
- **상태 머신 형태의 루프 구조가 동작 타이밍 제어 및 안정성 향상에 중요한 역할**
    
- **Modbus 프로토콜과 자체 프로토콜를 조합해 범용성과 성능 고려**
    
- **하드웨어의 실제 동작은 MCU GPIO 제어에 직접 연결되어 있음**
    

필요시, 각 단계 실무에 맞춰 더 자세한 구조도, 함수 호출 체인, 데이터 플로우 등의 문서화도 도와드릴 수 있습니다.  
추가로 특정 파일별 상세 내용, 이해에 어려운 부분, 예제 동작 흐름도 등을 요청해 주세요!

```mermaid
flowchart TD
    A[PC 소프트웨어] --> B[명령 생성]
    B --> C[SLIP 인코딩 + CRC16 체크섬]
    C --> D[시리얼 송신 (UART)]

    D --> E[MCU UART 수신 (NFSerial)]
    E --> F[수신 버퍼에 저장 + ISR 처리]
    F --> G[HostRun.cpp - 수신 패킷 완성 확인]

    G --> H{명령 종류 판별}
    H -->|R (Run Scent)| I1[DoScentBackLoop() 호출]
    H -->|G (Get Status)| I2[상태 읽기]
    H -->|C (Clear)| I3[DoClearBackLoop() 호출]
    H -->|V (Version)| I4[버전 응답]
    H -->|S (Stop)| I5[DoStopBackLoop() 호출]

    I1 --> J1[ScentControl 상태 머신 실행]
    I3 --> J3[ScentControl 세정 루프 실행]
    I5 --> J5[향/세정 루프 강제 중단]

    J1 --> K[IOControl - 솔레노이드 제어]
    J3 --> K
    J5 --> K

    K --> L[GPIO 상태 변경 (펌프, 밸브, LED)]

    I2 --> M1[현재 상태 데이터 구성]
    M1 --> N[SLIP 인코딩 + CRC16]
    N --> O[RS485 송신 (NFSerial)]

    I4 --> M2[버전 정보 응답]
    M2 --> N

    subgraph MCU 내부
        E
        F
        G
        H
        I1
        I2
        I3
        I4
        I5
        J1
        J3
        J5
        K
        L
        M1
        M2
        N
        O
    end
```
