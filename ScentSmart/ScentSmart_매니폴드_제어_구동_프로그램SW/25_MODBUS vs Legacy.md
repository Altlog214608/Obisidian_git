

---

# 🧭 MODBUS vs Legacy 커스텀 프로토콜 비교

|항목|MODBUS 스타일 (예: dsComm + MODBUS_Firmware)|Legacy 스타일 (예: HostRun 기반)|
|---|---|---|
|**🔧 프로토콜 표준성**|✅ 국제 표준 MODBUS RTU (산업용)|❌ 사내 정의 (문자 기반, 임의 구조)|
|**⚙️ 기능 구조**|레지스터 기반: `0x03`, `0x06`, `0x10` 등|Command 1바이트: `'R'`, `'L'`, `'S'` 등|
|**🔐 무결성 체크**|CRC16 (산업 표준)|XOR 2바이트 문자 (간단한 방식)|
|**🧠 장치 확장성**|다수 슬레이브, 주소 기반 확장 용이|단일 장치 위주 구조|
|**🛠️ 타 시스템 호환성**|PLC, HMI, LabVIEW 등과 연동 쉬움|외부 시스템 연동 불가 (직접 파싱 필요)|
|**📚 문서화 & 툴 지원**|완벽: MODSCAN, modbus-py, 스펙 문서|없음 (소스코드 기반 설명 필요)|
|**👨‍💻 개발 난이도**|높음 (CRC, 주소 정렬, 다중 슬레이브 등 고려)|낮음 (단순 ASCII 구조, 바로 로직 연결 가능)|
|**🔁 에러 처리**|MODBUS 예외코드 (Exception Code) 내장|없음. NACK 있긴 해도 처리 제한적|
|**🧪 디버깅 용이성**|표준 툴로 쉽게 확인 가능|커맨드별 파싱 확인해야 함|
|**⚡ 전송 속도/성능**|약간 느림 (헤더+CRC 있음)|매우 빠름 (간단한 구조)|
|**💡 최적 사용처**|산업용 제품, 외부 시스템과 연결 필수|개발용 장치, 단독 제어 장치, 시제품 등|

---

# 📌 예시 비교: "향 3번, 강도 80%, 5초 분사" 명령

### ✅ MODBUS 스타일:

```python
# Function Code 0x10 (Write Multiple Registers)
[ID=1][0x10][Address=0x0100][Length=3]
[Data=Delay=5, No=3, Power=80] + [CRC16]
```

### ✅ Legacy 스타일:

```
[STX][0x30][0x31]['R'][0x05][0x03][0x50]...[XOR][ETX]
```

- MODBUS는 **어디에(레지스터 주소)** 무엇을 쓰는지 명확히 나타냄.
    
- Legacy는 **Command 한 글자(R)**로 의미를 전달 → **명확하지만 구조화는 약함**.
    

---

# 🧠 상황별 추천

|상황|추천 방식|이유|
|---|---|---|
|프로토콜을 처음부터 설계|✅ Legacy|빠르고 단순, 테스트 용이|
|외부 시스템과 연결 필요|✅ MODBUS|타사 PLC, 제어 시스템 연동|
|장치 1~2개만 제어|Legacy|오버헤드 없음|
|여러 장치 제어, 주소 체계 필요|MODBUS|주소 기반 슬레이브 구조|
|양방향 통신 안전성 필요|MODBUS|CRC, 응답구조 내장|

---

# ✅ 요약 정리

|구분|MODBUS|Legacy|
|---|---|---|
|표준성|✅|❌|
|단순성|❌|✅|
|확장성|✅|❌|
|개발속도|❌|✅|
|디버깅 쉬움|✅ (툴 多)|❌|
|외부연동|✅|❌|
|테스트 편의|❌|✅|

---

## ✍️ Obsidian 문서용으로도 원하시면 바로 변환해드릴 수 있어요!

그리고 아래 내용도 원하시면 확장 가능합니다:

- CRC16 vs XOR 체크섬 실제 계산 예시
    
- 패킷 길이 및 속도 비교
    
- `ScentSmart`에 적용 시 구조 차이
    

