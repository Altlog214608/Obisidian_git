---
aliases:
  - 02_C/C++헤더파일과 JAVA_interface
---
네, 아주 좋은 비유예요!  
C/C++에서 **헤더 파일(.h)**을 사용하는 개념은 **Java에서 인터페이스(interface)**를 사용하는 것과 **"비슷한 목적"**을 가집니다. 하지만 **역할과 구현 방식에는 차이**가 있어요. 비교해서 쉽게 설명드릴게요.

---

## ✅ 공통점: “인터페이스 역할”

|공통 역할|설명|
|---|---|
|**"어떤 함수가 있다"**고 알려줌|C의 `.h` 파일은 함수 원형(선언)을 알려주고, Java 인터페이스는 메서드 시그니처를 정의함|
|**구현은 따로**|C에선 `.cpp`에서 구현하고, Java에선 인터페이스를 구현한 클래스에서 작성함|
|**다른 코드에서 쉽게 불러 사용**|`#include "xxx.h"` vs. `implements InterfaceName`|

---

## ✅ 차이점: 구현 방식

|항목|C 헤더 파일 (.h)|Java 인터페이스|
|---|---|---|
|**문법 형식**|함수/클래스 **선언만** 포함|메서드 시그니처만 선언 (보통 public abstract)|
|**구현 연결**|같은 이름의 `.cpp`에서 구현 (컴파일러가 연결)|클래스가 `implements`로 연결해서 구현함|
|**다중 구현 여부**|가능 (함수 선언만 하므로 제한 없음)|**다중 인터페이스 구현 가능**|
|**상속/오버라이딩**|없음 (단순 함수 선언/호출)|인터페이스는 반드시 구현해야 하며 상속 가능|

---

## ✅ 예시 비교

### Java 인터페이스

```java
public interface Speakable {
    void speak();  // 선언만
}

public class Dog implements Speakable {
    public void speak() {
        System.out.println("멍멍!");
    }
}
```

### C 헤더 + C++ 구현

```c++
// speakable.h
void speak();  // 함수 선언
```

```c++
// speakable.cpp
#include <iostream>
void speak() {
    std::cout << "멍멍!" << std::endl;
}
```

```c++
// main.cpp
#include "speakable.h"

int main() {
    speak();  // 호출
}
```

---

## ✅ 결론

- C의 `.h` 파일은 Java의 **인터페이스와 비슷하게 “형태(약속)”를 알려주는 역할**을 하지만,
    
- **상속·다형성·추상 클래스 같은 개념은 없음** → 그건 C++의 클래스와 가상 함수에서 다룸.
    

👉 그래서 **“헤더 파일 = Java 인터페이스 같은 선언부 역할”**이라고 보면 이해하기 좋고,  
👉 “상속, 구현 강제, 다형성” 같은 특성은 C++ 클래스나 `virtual` 키워드에서 구현됩니다.
