

## ✅ **실제 구조 요약**

- **SW(PC 소프트웨어, UI/앱) 역할**
    
    - 대부분의 동작(문제 출제, UI 전환, 결과집계, 엑셀 저장, 사용자 안내 등)은 SW 내부에서 처리합니다.
        
    - 발향(분사), 세정(클리닝), 정지(스톱) 등 직접 하드웨어와 관련된 기능이 필요할 때만
        
        - 바이트 패킷(명령+파라미터들: 향번호, 시간, 세기 등)을 만들어 시리얼로 펌웨어에 "OO해줘"라고 명령을 내립니다.
            
- **펌웨어(MCU) 역할**
    
    - 상위(SW)에서 명령이 들어올 때까지 대기
        
    - 명령을 받으면 실제 하드웨어(밸브, 펌프, 모터 등)를 제어해 분사/세정/정지/상태 변화 수행
        
    - 명령이 끝나면 "수행완료", "상태값", "에러" 등 결과만 SW에 응답 패킷으로 리턴
        
    - 특별한 센서 이벤트(예: 에러, 이상상황, 센서값 변화)나 주기적 상태 보고 등도 필요시 반환
        

## 🔵 **즉, 핵심 통신 흐름**

1. **SW:** 명령 필요 시(분사/세정/정지) → [바이트 패킷 전송]
    
2. **펌웨어:** 명령 받음 → 실제 분사/세정 동작 → 결과/상태/에러값만 [패킷으로 응답]
    

- 나머지 모든 UI 화면/결과 저장/로그/UI 상태 전환 등은 **SW 내부에서 자체 처리**하며
    
- 펌웨어는 딱 "물리 동작"(실행/제어/종료/상태보고)에 집중, "명령받고-수행하고-결과알림"만 반복
    

## 🟢 **결론 (쉽게 한 줄로):**

> **분사와 세정처럼 실제 하드웨어 동작이 필요할 때만 SW↔펌웨어 통신이 오가고, 나머지 모든 UI, 검사 흐름, 데이터관리는 SW(앱) 내부에서만 처리된다!**

아래는 시리얼(C↔Python) 통신에서 각 함수, 각 버퍼, 실제 바이트 데이터가 어떻게 오가는지 구조적으로 쉽게 설명한 내용입니다.

# 1. **통신 기본 구조**

- **Python**: PC에서 바이트(명령, 값 등) 묶음을 시리얼(USB to RS232 등)을 통해 보냄
    
- **MCU/펌웨어(C)**: 시리얼 포트에 바이트가 도착하면 버퍼에 저장 → 필요한 함수들이 이를 꺼내 처리
    

# 2. **주요 함수와 데이터 버퍼 역할**

## (1) **C(펌웨어)단 - 구조체와 함수**

## **a. s_SERIAL 구조체**



```c
struct s_SERIAL {     
unsigned char read[SIZEBUFFER], send[SIZEBUFFER];    
int sendbyte, readbyte;    
int port, baudrate, parity, databits, stopbits, error;    
double timeout;    
char flagopen;    
char starter, terminator;    
int protocol, crc;    
int mode, debug;    
int add; };
```

- **read[]**: 시리얼 "수신" 데이터 저장 (Python에서 온 바이트들)
    
- **send[]**: 시리얼 "송신" 데이터 저장 (MCU에서 Python/PC로 보내는 바이트들)
    
- **readbyte/sendbyte**: 실제 수신/송신 바이트 개수(=payload size)
    
- 기타 변수: 포트 세팅, 통신에러 정보, 체크모드 등
    

## **b. Python→C 데이터 흐름 함수**

## **1) InstallComCallback & ComCallback**

- 이벤트 기반 수신용 콜백 지정
    
- 데이터가 도착할 때마다 자동 호출해 아래 **ReadFromCom()** 실행
    

## **2) ReadFromCom()**

- 실제로 read 버퍼(즉, scom->read)로 데이터 복사
    
- terminator 방식(문자 기준으로 끊김) or 길이만큼 다 읽기
    
- 읽은 후 scom->readbyte에 저장
    

## **3) DecodePacket()**

- **read[]**에 담긴 바이트(예: 명령어, 값 등)를 파싱해서 명령 실행  
    예) s_serial.read=ID, s_serial.read[1](https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/72041696/6ea26fc2-9e2b-43eb-9434-7d868e463f83/ConfigCOM.c)=명령, .../센서데이터, ...
    
- 명령에 따라 모터, 센서 등 하드웨어 제어하거나 응답 패킷 생성
    

## **4) SendToCom()**

- send[] 버퍼에 데이터 담아 PC로 전송
    
- CRC 등 후처리(붙이기) 후 ComWrt 등으로 실제 전송
    

## (2) **Python 단 - 함수와 데이터**

## **dsComm.py, FrSmart.py 등**

- `sendMsgForEmitClean()`, `sendMsgReadRegister()` 등에서 struct.pack 등으로 payload 생성
    
- 시리얼 라이브러리로 .write() 하면 그 값이 바로 C로 전달
    

## **예시 코드**

python

```python
# sendMsgForEmitClean 예를 들어 
payload = mid + mfunc + maddress + ... + mdata_cleanup_delay payload += crc16_modbus(0xFFFF, payload, len(payload)) serial.write(payload)
```

→ C read[]로 들어감

# 3. **바이트 단위 실제 데이터 오고감 (예시)**

## (1) Python에서 보낼 때

- payload = [ID, 명령, 레지스터주소, 값1(high), 값1(low), 값2(high) ... CRC1 CRC2]
    
    - ex: [0x01, 0x10, 0x10, 0x68, ... 바이트들, CRC LSB, CRC MSB]
        
- 이걸 직렬 송신
    

## (2) C에서 받을 때

- read = 0x01 (ID)
    
- read[1](https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/72041696/6ea26fc2-9e2b-43eb-9434-7d868e463f83/ConfigCOM.c) = 0x10 (명령 코드)
    
- read[2](https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/72041696/e4f528e1-73e2-4306-9af6-7bd10a292b6c/ConfigCOM.h)~... = 데이터 바이트들
    
- read[] 최후단 = CRC 바이트들 (무결성 검사용)
    

**→ 함수 흐름**  
(PC에서 write)  
→(MCU 콜백)→ReadFromCom(read[])→DecodePacket(read[] 해석)→동작(펌프 구동, 응답 송신 등)

# 4. **CRC/무결성 검사 및 송신/응답**

- **CheckCRC16, CheckModbusCRC**: 들어온 바이트가 깨졌는지, 변조 없는지 확인
    
- **AttachCRC16, AttachModbusCRC**: MCU에서 응답 보낼 때 CRC 바이트 붙여줌
    
- 통신 문제시 ErrorCom() 등으로 코드 및 메시지 띄움
    

# 5. **최종 동작 요약**

|단계|하는 일|
|---|---|
|Python에서 바이트 패킷 생성|struct.pack, bytes 등 사용하여 원하는 명령/값 패킹, CRC 붙이고 송신|
|C에서 read[]에 데이터 수신|ReadFromCom()에서 버퍼에 복사, 바이트수 저장|
|CRC 검사(데이터 변조 체크)|CheckCRC* 함수로 무결성 검사|
|데이터 해석 및 명령 실행|DecodePacket()에서 read[] 값대로 실구동(모터 등) 또는 응답 준비|
|MCU에서 PC로 응답 보냄|send[]에 값/상태 담아 CRC 붙여 SendToCom()로 송신|

# 6. **실전 팁**

- **read[]/send[]**는 항상 패킷 그대로(바이트 단위) 들어오고 나감
    
- 각 함수는 중간중간 바이트 수 검사(`readbyte`, `sendbyte`), CRC 검사 필수
    
- 실제 동작(모터, 센서 제어 등)은 DecodePacket에서 분기 처리
    

필요하다면 각 구조/함수가 해석하는 패킷 포맷 예시, 바이트별 의미까지 더 설명 가능합니다!
