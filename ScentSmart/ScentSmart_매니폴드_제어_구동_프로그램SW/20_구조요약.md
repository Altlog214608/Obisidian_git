

## ✅ **실제 구조 요약**

- **SW(PC 소프트웨어, UI/앱) 역할**
    
    - 대부분의 동작(문제 출제, UI 전환, 결과집계, 엑셀 저장, 사용자 안내 등)은 SW 내부에서 처리합니다.
        
    - 발향(분사), 세정(클리닝), 정지(스톱) 등 직접 하드웨어와 관련된 기능이 필요할 때만
        
        - 바이트 패킷(명령+파라미터들: 향번호, 시간, 세기 등)을 만들어 시리얼로 펌웨어에 "OO해줘"라고 명령을 내립니다.
            
- **펌웨어(MCU) 역할**
    
    - 상위(SW)에서 명령이 들어올 때까지 대기
        
    - 명령을 받으면 실제 하드웨어(밸브, 펌프, 모터 등)를 제어해 분사/세정/정지/상태 변화 수행
        
    - 명령이 끝나면 "수행완료", "상태값", "에러" 등 결과만 SW에 응답 패킷으로 리턴
        
    - 특별한 센서 이벤트(예: 에러, 이상상황, 센서값 변화)나 주기적 상태 보고 등도 필요시 반환
        

## 🔵 **즉, 핵심 통신 흐름**

1. **SW:** 명령 필요 시(분사/세정/정지) → [바이트 패킷 전송]
    
2. **펌웨어:** 명령 받음 → 실제 분사/세정 동작 → 결과/상태/에러값만 [패킷으로 응답]
    

- 나머지 모든 UI 화면/결과 저장/로그/UI 상태 전환 등은 **SW 내부에서 자체 처리**하며
    
- 펌웨어는 딱 "물리 동작"(실행/제어/종료/상태보고)에 집중, "명령받고-수행하고-결과알림"만 반복
    

## 🟢 **결론 (쉽게 한 줄로):**

> **분사와 세정처럼 실제 하드웨어 동작이 필요할 때만 SW↔펌웨어 통신이 오가고, 나머지 모든 UI, 검사 흐름, 데이터관리는 SW(앱) 내부에서만 처리된다!**

