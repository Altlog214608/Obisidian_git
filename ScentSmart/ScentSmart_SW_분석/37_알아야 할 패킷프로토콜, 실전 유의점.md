---
aliases:
  - 37_알아야 할 패킷/프로토콜
  - 실전 유의점
---
 아주 쉽게 하나씩 설명해 드릴게요.  
아래는 MCU(펌웨어)와 Python(PC) 사이에 **시리얼 통신으로 장비를 제어**할 때 꼭 알아야 할 “패킷/프로토콜”과 실전 유의점입니다.

## 1. **MCU가 요구하는 패킷의 포맷(순서/데이터 타입/엔디안) 완벽 이해**

## a. **순서(패킷 구조)**

- MCU와 PC(파이썬)는 "정해진 순서"로 데이터를 주고받아요.
    
- 예(가상):
    
    text
    
    `[ID][명령][주소][데이터][CRC]`
    
    - ID: 장치 번호, 1바이트
        
    - 명령: 동작(emit, clean 등), 1바이트
        
    - 주소: 데이터 읽고 쓸 위치, 2바이트
        
    - 데이터: 실제 설정값, 예를들면 펌프 Power, 2바이트
        
    - CRC: 에러검사 체크값, 2바이트
        

## b. **데이터 타입(크기, 형식)**

- MCU는 보통 **unsigned char(1바이트)**, **unsigned short(2바이트)** 등으로 데이터를 받음.
    
- 파이썬에서 보낼 때도 “1바이트짜리 숫자/2바이트짜리 숫자” 정확하게 맞춰서 넣어야 함.
    

## c. **엔디안(Endianness)**

- MCU마다 다를 수 있는데, 대부분 “Little Endian”이나 “Big Endian” 지정됨.
    
- 예시: 0x1234라는 2바이트를
    
    - Big Endian: 12 34
        
    - Little Endian: 34 12
        
- Python struct에서 `">H"`(big), `"<H"`(little)로 맞춰줘야 함.
    

## 2. **파이썬에서 정확하게 바이너리 바이트 만들기**

## a. **struct.pack / bytes 구조**

- struct.pack을 쓰면 C와 호환되는 정밀한 바이너리 데이터를 만들 수 있음.
    
    ```python

import struct

  

# Example Packet Format:

# [ID(1 byte)][CMD(1 byte)][ADDR(2 bytes)][DATA(2 bytes)][CRC(2 bytes)]

  

packet = (

    struct.pack('B', 1) +            # ID (unsigned char)

    struct.pack('B', 0x10) +         # Command

    struct.pack('>H', 0x106A) +      # Address (Big Endian)

    struct.pack('>H', 70)            # Data (Big Endian)

    # CRC to be added...

)

```
    
- 여러 개 연결(패킷 조립):
    
    python
    
    `# [ID][CMD][ADDR][DATA][CRC] pkt = struct.pack('B', 1) + struct.pack('B', 4) + struct.pack('>H', 0x106A) + struct.pack('>H', 70) # ... 뒤에 CRC도 붙이기!`
    

## b. **int/float/bool 변환 예**

- int, float, bool 값을 반드시 MCU 요구 형태로 바이트화
    
    - int 16 (2 bytes): `struct.pack('>H', 16)`
        
    - float 32 (4 bytes): `struct.pack('>f', 3.14)`
        
    - bool (1 byte): `struct.pack('B', True)`
        

## 3. **오류, 타임아웃 등 상황별 처리**

## a. **무응답(Timeout)**

- 명령 보냈는데 일정 시간내 “응답이 안 옴” → 프로그램상 재시도하거나 “오류” 메시지 띄움
    
- PySerial 예:
    
    ```python

import serial

  

try:

    data = serial.read(size=10, timeout=2.0)

    if data == b'':

        print("No response from device. Retry or report error.")

except Exception as e:

    print(f"Serial communication error: {e}")

```
    

## b. **CRC mismatch 감지**

- 응답을 받았는데 마지막 CRC 체크섬이 다르면? → 데이터 변질, 이때도 에러 처리 필요
    
- 제대로 해석하지 말고, “다시 시도” 메시지, 에러 사운드 등으로 예외처리해야 함
    

## c. **장비 Busy 상황**

- 응답코드 혹은 에러코드 값이 “busy” 등을 알려줄 수 있음
    
- 이 또한 코드에서 해석해서 안내 or 재시도 처리
    

## 4. **임베디드(C)쪽 명령 해석 위치까지 확인 가능해야 함**

## a. **패킷 구조 바꾸거나 신규 명령 추가시**

- 예를 들어, Python에서 명령 구조를 바꿨다면, **MCU 펌웨어에서 데이터를 어떻게 읽는지**(C로 작성된 코드)를 반드시 확인해야 함
    
- 예)
    
    - 명령 바이트 추가: MCU C코드에서 배열로 몇번째 바이트가 무슨 값인지 잘 해석하는지 체크
        
    - CRC 계산 위치/방법: Start~끝 이전까지인지, 일부만 하는지, 순서가 바뀌진 않았는지 확인
        

## b. **실제 코드에서 파싱 예시**



```c
// MCU 펌웨어 (C) 
void parseCommand(uint8_t* rx, int length) 
{    
uint8_t id    = rx[0];   
uint8_t cmd   = rx[1];    
uint16_t addr = (rx[2] << 8) | rx[3];
// Big endian로 해석 예시    
// ... 이하 생략
}
```


- Python에서 만든 바이트 배열이 **MCU에서 제대로 해석(파싱)되는지** 실물 또는 시뮬레이터에서 꼭 검증해야 함!
    

## ⭐️ 정리

- **MCU가 원하는 구조(순서, 바이트 수, 엔디안, CRC) 정확히 맞춰야 장비가 제대로 동작**합니다.
    
- 파이썬에서 struct/bytes 등으로 “바이트 배열”을 잘 만들고,
    
- 통신 에러(무응답, CRC실패 등) 상황을 코드로 잘 처리해야 함.
    
- 구조 바뀔 땐 항상 MCU 펌웨어 소스를 같이 보고 파싱/CRC구간 등 싱크를 맞춰야 함.
    

## 💡개념적으로는

- **“같은 언어”가 아니라 “같은 규칙대로 바이트를 주고 받는 언어”로 소통한다**
    
- 이 규칙이 어긋나면 어떤 장비도 명령을 이해하지 못합니다!
    
- 그래서 **C(임베디드) 코드와 Python(PC) 코드가 맞물려 동작하는 것**입니다.
    
