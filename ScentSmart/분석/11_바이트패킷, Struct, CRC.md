# ✅ 시리얼 바이트 패킷과 구조적 이해

  

## 1. 바이트 패킷이란?

  

- **바이트 패킷(byte packet)**은 하드웨어(예: scent 기기)와 프로그램이 **서로 주고받는 명령/데이터 묶음**입니다.

- 0~255의 값을 갖는 **한글자(byte, 8비트)**들이 연속적으로 배열된 "연속 메모리" 블럭 형태입니다.

- 한 패킷은 다음 구성으로 이루어짐(예시):

  ```

  [장치ID][명령코드][주소][정보][...][체크섬]

  ```

  (각 필드는 1~몇십 바이트로, 하드웨어가 '순서대로 쪼개서 읽음')

  

- **목적:** 기계가 오동작 없이, 정확하게 "명령: 이런 동작 해!" 또는 "데이터: 결과 이거야!"를 전달받게 하려는 것.

  

---

  

## 2. struct의 역할

  

- 파이썬 struct 모듈은 **숫자·문자 등 자료형을 0~255의 바이트 시퀀스로 변환**합니다.

- 예)

  - 숫자 4200 → 16진수 0x1068 → 바이트: `\x10\x68`

  - `struct.pack(">H", 4200)`  

     - **">"**: big-endian(큰값이 앞으로) 정렬

     - **H**: unsigned short(2바이트)

     - **결과**: `b'\x10\x68'`

  

- 이 작업이 필요한 이유는, 컴퓨터 내부 숫자 자료형(예: int)은 하드웨어끼리 다르게 저장될 수 있어, 바이트 단위 "표준 포맷"으로 바꿔야 장비와 1:1 대화가 가능하기 때문.

  

---

  

## 3. 체크섬(CRC)의 의미와 목적

  

- **체크섬(checksum)**, 그중에서도 **CRC(Cyclic Redundancy Check)**는

  - **패킷이 신호기기에서 기기까지 전송되는 동안 에러 없이 도착했는지 검증**하는 숫자 코드(1~수바이트).

- **패킷 끝**에 붙습니다. (예: `[DATA..][체크섬2byte]`)

  

### CRC16 (MODBUS)의 원리

  

- **dsComm에서는** CRC-16 MODBUS 규격 사용 → 패킷 바이트 전체를 공식에 집어넣어 2byte(16비트) 숫자를 만듦

  - 함수: `crc16_modbus(0xFFFF, mdata, len(mdata))`

- 하드웨어도 똑같이 계산해서 도착한 메시지의 체크섬이 "계산값과 일치"하면 **정상**으로 처리, 오동작·노이즈 시 "버림" 처리.

  

**이유:** 산업장비나 의료기기에서는 아주 짧은 순간의 오류도 큰 문제를 일으킬 수 있어, 자동 검증은 필수입니다.

  

---

  

## 4. 왜 16진수(HEX)를 쓰는가?

  

- 바이트 패킷 하나하나는 0~255(1byte, 8bit) 숫자 → **16진수(2글자)로 표기하면 사람이 쉽게 구분하고 읽음**

  - 예) 10진수 10 = 0x0A, 255 = 0xFF

- 프로토콜·패킷 설명, 디버깅 콘솔 등에서 항상 `0xAB 0xC1 ...` 형태로 출력.

- 여러 바이트를 이어서 표기해야 할 때도 잘 맞아떨어짐(1바이트=2글자, 2바이트=4글자).

- **프로그래밍/하드웨어 세계에서 바이트 값들을 "헥스(byte hex)"로 보는 게 표준!**

  

---

  

## 5. 실제 구성 예시 (`dsComm.sendMsgForEmitClean`)

  

(1) 입력으로 "번호/세기/시간/딜레이" 등의 파라미터 값을 받음  

(2) 각 파라미터를 struct로 바이트로 포장  

(3) 모든 바이트들 합친 뒤  

(4) CRC16 체크섬(2byte) 추가  

(5) **→ 하나의 패킷(byte array) 완성 → 시리얼 전송**

  

```python

# 패킷 생성 과정 핵심 라인

mid = bytes([id])

mfunc = bytes([func])

maddress = struct.pack(">H", address)

# ... 각종 필드 생략 ...

mdata = mid + mfunc + maddress + ... + mdata_cleanup_delay

wdata = mdata + crc16_modbus(0xFFFF, mdata, len(mdata))

```

  

- **결과물 `wdata`:** "이 장치야, 이 동작(명령/값) 해! (마지막에 CRC 붙임)"

  

---

  

## ✅ 요약 정리

  

| 항목     | 핵심 요약 |

|--------|----------|

| 바이트 패킷 | 장치 간 통신용 데이터 묶음 (바이트 단위 정렬) |

| struct | 데이터를 바이트로 변환하는 도구 (통신 호환용) |

| CRC16 | 전송 에러를 자동 검출하는 검증 숫자 |

| HEX 표기 | 바이트 단위를 사람이 보기 쉽게 표현하는 방법 |


## ✅ struct 패킹 설명

|인자|구조 (Hex)|설명|
|---|---|---|
|id=1|0x01|장치번호|
|func=6|0x06|명령코드(단일쓰기)|
|address=4212|0x10 74|레지스터 주소(2바이트)|
|command=400|0x01 90|써줄값(2바이트)|
|crc16|0xCC EC|MODBUS CRC 체크섬|

- **총 8바이트**
    
- 각 값은 struct로 변환/포장(예: `struct.pack(">H", address)`)
    

## 🏷️ MODBUS, 레지스터, CRC16이란?

- **MODBUS**: 산업용 국제 통신 규격, 1~N개 장치가 주소(ID), 명령코드, 주소, 데이터, CRC 규격에 따라 정보를 주고받음.
    
- **레지스터**: 하드웨어 내부의 “작은 기억칸(주소 있는 변수)”로, 명령/센서/상태 값 저장
    
- **CRC16**: 데이터 전송 중 오류 검출 위한 2바이트 체크섬 (빠른 계산 위해 crc16_table 활용)
    

## ✅ CRC16 계산 아이디어 (코드 예시)

python

`def crc16_modbus(init_crc, dat, length):     crc = [init_crc >> 8, init_crc & 0xFF]    for b in dat:        tmp = crc16_table[crc[0] ^ b]        crc[0] = (tmp & 0xFF) ^ crc[1]        crc[1] = tmp >> 8    return struct.pack("H", (crc[1] << 8) | crc[0])`

- **crc16_table**: 계산 효율화용 precomputed 256 엔트리 테이블
    
    
    